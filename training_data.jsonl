{"source": "-- Input: Oracle SQL limiting rows\nSELECT employee_id, name\nFROM employees\nWHERE ROWNUM <= 10;", "target": "-- Output: Databricks SQL limiting rows\nSELECT employee_id, name\nFROM employees\nLIMIT 10;"}
{"source": "-- oracle date and time sample \nSELECT TO_DATE('2023-08-28', 'YYYY-MM-DD') AS formatted_date, SYSDATE AS current_date FROM DUAL;", "target": "-- databrikcs sql output for sample1 date and time sample\nSELECT TO_DATE('2023-08-28', 'YYYY-MM-DD') AS formatted_date, SYSDATE AS current_date FROM DUAL;"}
{"source": "-- oracle sql sameple for string function\nSELECT SUBSTR('Databricks', 1, 5) AS substring, INSTR('Databricks', 'b') AS position FROM DUAL;", "target": "-- databrics samples output for sample2 string sample\nSELECT substring('Databricks', 1, 5) AS substring, instr('Databricks', 'b') AS position;"}
{"source": "-- oracle sample Hierarchical Queries\nSELECT employee_id, manager_id\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;", "target": "-- databricks sample3 output for sample 3 hierarchical queries\nWITH recursive_cte AS (\n  SELECT employee_id, manager_id\n  FROM employees\n  WHERE manager_id IS NULL\n  UNION ALL\n  SELECT e.employee_id, e.manager_id\n  FROM employees e\n  JOIN recursive_cte r ON e.manager_id = r.employee_id\n)\nSELECT * FROM recursive_cte;"}
{"source": "-- oracle sample window functions\nSELECT employee_id, salary, \n       RANK() OVER (ORDER BY salary DESC) as rank\nFROM employees;", "target": "-- databrikcs output for sample 4 window functions\nSELECT employee_id, salary, \n       RANK() OVER (ORDER BY salary DESC) as rank\nFROM employees;"}
{"source": "-- sql example for partitioning \nCREATE TABLE employees_partitioned (\n  employee_id NUMBER,\n  department_id NUMBER,\n  salary NUMBER\n) PARTITION BY RANGE (salary) (\n  PARTITION p1 VALUES LESS THAN (5000),\n  PARTITION p2 VALUES LESS THAN (10000),\n  PARTITION p3 VALUES LESS THAN (MAXVALUE)\n);", "target": "-- databrics output for sample 5 partitioning \nCREATE TABLE employees_partitioned (employee_id INT, department_id INT, salary INT)\nUSING DELTA\nPARTITIONED BY (salary);"}
{"source": "-- Input: Oracle handeling null values\nSELECT NVL(salary, 0) AS adjusted_salary\nFROM employees\nWHERE job_id IS NULL;", "target": "-- Output: Databricks SQL handeling null values\nSELECT COALESCE(salary, 0) AS adjusted_salary\nFROM employees\nWHERE job_id IS NULL;"}
{"source": "-- Input: Oracle SQL temporary tables \nCREATE GLOBAL TEMPORARY TABLE temp_employees (employee_id NUMBER, name VARCHAR2(50))\nON COMMIT DELETE ROWS;\nINSERT INTO temp_employees VALUES (1, 'John');", "target": "-- Output: Databricks SQL temporary tables \nCREATE TEMPORARY VIEW temp_employees AS\nSELECT 1 AS employee_id, 'John' AS name;"}
{"source": "-- Input: Oracle SQL concatanation\nSELECT first_name || ' ' || last_name AS full_name\nFROM employees;", "target": "-- Output: Databricks SQL concatanation\nSELECT CONCAT(first_name, ' ', last_name) AS full_name\nFROM employees;"}
{"source": "-- Input: Oracle SQL case sensitivity\nSELECT employee_id, name\nFROM employees\nWHERE UPPER(name) = 'JOHN';", "target": "-- Output: Databricks SQL case sensitivity\nSELECT employee_id, name\nFROM employees\nWHERE name ILIKE 'JOHN';"}
